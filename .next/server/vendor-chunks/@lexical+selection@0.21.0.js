"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+selection@0.21.0";
exports.ids = ["vendor-chunks/@lexical+selection@0.21.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@lexical+selection@0.21.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+selection@0.21.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $addNodeStyle: () => (/* binding */ $addNodeStyle),\n/* harmony export */   $cloneWithProperties: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties),\n/* harmony export */   $getSelectionStyleValueForProperty: () => (/* binding */ $getSelectionStyleValueForProperty),\n/* harmony export */   $isAtNodeEnd: () => (/* binding */ $isAtNodeEnd),\n/* harmony export */   $isParentElementRTL: () => (/* binding */ $isParentElementRTL),\n/* harmony export */   $moveCaretSelection: () => (/* binding */ $moveCaretSelection),\n/* harmony export */   $moveCharacter: () => (/* binding */ $moveCharacter),\n/* harmony export */   $patchStyleText: () => (/* binding */ $patchStyleText),\n/* harmony export */   $selectAll: () => (/* binding */ $selectAll),\n/* harmony export */   $setBlocksType: () => (/* binding */ $setBlocksType),\n/* harmony export */   $shouldOverrideDefaultCharacterSelection: () => (/* binding */ $shouldOverrideDefaultCharacterSelection),\n/* harmony export */   $sliceSelectedTextNodeContent: () => (/* binding */ $sliceSelectedTextNodeContent),\n/* harmony export */   $trimTextContentFromAnchor: () => (/* binding */ $trimTextContentFromAnchor),\n/* harmony export */   $wrapNodes: () => (/* binding */ $wrapNodes),\n/* harmony export */   createDOMRange: () => (/* binding */ createDOMRange),\n/* harmony export */   createRectsFromDOMRange: () => (/* binding */ createRectsFromDOMRange),\n/* harmony export */   getCSSFromStyleObject: () => (/* binding */ getCSSFromStyleObject),\n/* harmony export */   getStyleObjectFromCSS: () => (/* binding */ getStyleObjectFromCSS),\n/* harmony export */   trimTextContentFromAnchor: () => (/* binding */ trimTextContentFromAnchor)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(rsc)/./node_modules/.pnpm/lexical@0.21.0/node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\n\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  //sort rects from top left to bottom right.\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top;\n    // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n    return top;\n  });\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude rects that overlap preceding Rects in the sorted list.\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;\n    // Exclude selections that span the entire element\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\n\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  if (!css) {\n    return styleObject;\n  }\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      if (key && value) {\n        styleObject[key.trim()] = value.trim();\n      }\n    }\n  }\n  return styleObject;\n}\n\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n  return value;\n}\n\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (textNode.isSelected(selection) && !textNode.isSegmented() && !textNode.isToken() && anchorAndFocus !== null) {\n    const [anchor, focus] = anchorAndFocus;\n    const isBackward = selection.isBackward();\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const [anchorOffset, focusOffset] = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCharacterOffsets)(selection);\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n  return textNode;\n}\n\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  const node = point.getNode();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    throw Error(`isAtNodeEnd: node must be a TextNode or ElementNode`);\n  }\n  return point.offset === node.getChildrenSize();\n}\n\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\nfunction $trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n      const lastDescendant = currentNode.getLastDescendant();\n      if (lastDescendant !== null) {\n        currentNode = lastDescendant;\n      }\n    }\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        nextNode = parentSibling;\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const currentNodeSize = text.length;\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0 && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(parent)) {\n        parent.remove();\n      }\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(key);\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\n\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\nfunction $patchStyle(target, patch) {\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (typeof value === 'function') {\n      styles[key] = value(prevStyles[key], target);\n    } else if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  } || {});\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  target.setStyle(newCSSText);\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return;\n  }\n  const [anchor, focus] = anchorAndFocus;\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n  if (selection.isCollapsed() && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    $patchStyle(selection, patch);\n    return;\n  }\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  const isBefore = anchor.isBefore(focus);\n  let startOffset = isBefore ? anchorOffset : focusOffset;\n  let endOffset = isBefore ? focusOffset : anchorOffset;\n  const startType = isBefore ? anchor.type : focus.type;\n  const endType = isBefore ? focus.type : anchor.type;\n  const endKey = isBefore ? focus.key : anchor.key;\n\n  // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode) && startOffset === firstNodeTextLength) {\n    const nextSibling = firstNode.getNextSibling();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  }\n\n  // This is the case where we only selected a single node\n  if (selectedNodes.length === 1) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode) && firstNode.canHaveFormat()) {\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset;\n\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n\n      // The entire node is selected or a token/segment, so just format it\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTokenOrSegmented)(firstNode) || startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n  } else {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode) && startOffset < firstNode.getTextContentSize() && firstNode.canHaveFormat()) {\n      if (startOffset !== 0 && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTokenOrSegmented)(firstNode)) {\n        // the entire first node isn't selected and it isn't a token or segmented, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n        if (isBefore) {\n          anchor.set(firstNode.getKey(), startOffset, 'text');\n        } else {\n          focus.set(firstNode.getKey(), startOffset, 'text');\n        }\n      }\n      $patchStyle(firstNode, patch);\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(lastNode) && lastNode.canHaveFormat()) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n\n      // The last node might not actually be the end node\n      //\n      // If not, assume the last node is fully-selected unless the end offset is\n      // zero.\n      if (lastNode.__key !== endKey && endOffset !== 0) {\n        endOffset = lastNodeTextLength;\n      }\n\n      // if the entire last node isn't selected and it isn't a token or segmented, split it\n      if (endOffset !== lastNodeTextLength && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTokenOrSegmented)(lastNode)) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      if (endOffset !== 0 || endType === 'element') {\n        $patchStyle(lastNode, patch);\n      }\n    }\n\n    // style all the text nodes in between\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(selectedNode) && selectedNode.canHaveFormat() && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchStyle(selectedNode, patch);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param createElement - The function that creates the node. eg. $createParagraphNode.\n */\nfunction $setBlocksType(selection, createElement) {\n  if (selection === null) {\n    return;\n  }\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  if (anchor !== null && anchor.key === 'root') {\n    const element = createElement();\n    const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n    const firstChild = root.getFirstChild();\n    if (firstChild) {\n      firstChild.replace(element, true);\n    } else {\n      root.append(element);\n    }\n    return;\n  }\n  const nodes = selection.getNodes();\n  const firstSelectedBlock = anchor !== null ? $getAncestor(anchor.getNode(), INTERNAL_$isBlock) : false;\n  if (firstSelectedBlock && nodes.indexOf(firstSelectedBlock) === -1) {\n    nodes.push(firstSelectedBlock);\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!INTERNAL_$isBlock(node)) {\n      continue;\n    }\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      throw Error(`Expected block node to be an ElementNode`);\n    }\n    const targetElement = createElement();\n    targetElement.setFormat(node.getFormatType());\n    targetElement.setIndent(node.getIndent());\n    node.replace(targetElement, true);\n  }\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\n\n/**\n * @deprecated\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0)) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$hasAncestor)(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n        throw Error(`Expected node in emptyElements to be an ElementNode`);\n      }\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentNode)(selection.focus, isBackward);\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(possibleNode) && !possibleNode.isIsolated() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\n}\n\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\n\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\n\n/**\n * Expands the current Selection to cover all of the content in the editor.\n * @param selection - The current selection.\n */\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode)) {\n    firstType = 'text';\n  } else if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n  }\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\n\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() && selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\n\n/**\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nfunction INTERNAL_$isBlock(node) {\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(node)) {\n    return false;\n  }\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(firstChild) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @deprecated renamed to {@link $trimTextContentFromAnchor} by @lexical/eslint-plugin rules-of-lexical */\nconst trimTextContentFromAnchor = $trimTextContentFromAnchor;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrc2VsZWN0aW9uQDAuMjEuMC9ub2RlX21vZHVsZXMvQGxleGljYWwvc2VsZWN0aW9uL0xleGljYWxTZWxlY3Rpb24uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1VDtBQUN4UTs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9EQUFXO0FBQ2pCO0FBQ0E7QUFDQSxNQUFNLG9EQUFXO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwREFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0seURBQWdCO0FBQ3RCO0FBQ0E7QUFDQSxPQUFPLHVEQUFjLFVBQVUsNERBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx5REFBZ0IsZ0JBQWdCLG9EQUFXO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsa0NBQWtDO0FBQzlEOztBQUVxWiIsInNvdXJjZXMiOlsiL1VzZXJzL3Rvc2gvRG9jdW1lbnRzL1BsYXRmb3JtSU8vUHJvamVjdHMvc3RyYXBpNS9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrc2VsZWN0aW9uQDAuMjEuMC9ub2RlX21vZHVsZXMvQGxleGljYWwvc2VsZWN0aW9uL0xleGljYWxTZWxlY3Rpb24uZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7ICRpc1RleHROb2RlLCAkZ2V0Q2hhcmFjdGVyT2Zmc2V0cywgJGlzRWxlbWVudE5vZGUsICRpc1Jvb3ROb2RlLCAkZ2V0Tm9kZUJ5S2V5LCAkZ2V0UHJldmlvdXNTZWxlY3Rpb24sICRjcmVhdGVUZXh0Tm9kZSwgJGlzUmFuZ2VTZWxlY3Rpb24sICRpc1Rva2VuT3JTZWdtZW50ZWQsICRnZXRSb290LCAkaXNSb290T3JTaGFkb3dSb290LCAkaGFzQW5jZXN0b3IsICRpc0xlYWZOb2RlLCAkc2V0U2VsZWN0aW9uLCAkZ2V0QWRqYWNlbnROb2RlLCAkaXNEZWNvcmF0b3JOb2RlLCAkaXNMaW5lQnJlYWtOb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5leHBvcnQgeyAkY2xvbmVXaXRoUHJvcGVydGllcyB9IGZyb20gJ2xleGljYWwnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBDU1NfVE9fU1RZTEVTID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGdldERPTVRleHROb2RlKGVsZW1lbnQpIHtcbiAgbGV0IG5vZGUgPSBlbGVtZW50O1xuICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldERPTUluZGV4V2l0aGluUGFyZW50KG5vZGUpIHtcbiAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBuZXZlciBoYXBwZW4nKTtcbiAgfVxuICByZXR1cm4gW3BhcmVudCwgQXJyYXkuZnJvbShwYXJlbnQuY2hpbGROb2RlcykuaW5kZXhPZihub2RlKV07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNlbGVjdGlvbiByYW5nZSBmb3IgdGhlIERPTS5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3IuXG4gKiBAcGFyYW0gYW5jaG9yTm9kZSAtIFRoZSBhbmNob3Igbm9kZSBvZiBhIHNlbGVjdGlvbi5cbiAqIEBwYXJhbSBfYW5jaG9yT2Zmc2V0IC0gVGhlIGFtb3VudCBvZiBzcGFjZSBvZmZzZXQgZnJvbSB0aGUgYW5jaG9yIHRvIHRoZSBmb2N1cy5cbiAqIEBwYXJhbSBmb2N1c05vZGUgLSBUaGUgY3VycmVudCBmb2N1cy5cbiAqIEBwYXJhbSBfZm9jdXNPZmZzZXQgLSBUaGUgYW1vdW50IG9mIHNwYWNlIG9mZnNldCBmcm9tIHRoZSBmb2N1cyB0byB0aGUgYW5jaG9yLlxuICogQHJldHVybnMgVGhlIHJhbmdlIG9mIHNlbGVjdGlvbiBmb3IgdGhlIERPTSB0aGF0IHdhcyBjcmVhdGVkLlxuICovXG5mdW5jdGlvbiBjcmVhdGVET01SYW5nZShlZGl0b3IsIGFuY2hvck5vZGUsIF9hbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgX2ZvY3VzT2Zmc2V0KSB7XG4gIGNvbnN0IGFuY2hvcktleSA9IGFuY2hvck5vZGUuZ2V0S2V5KCk7XG4gIGNvbnN0IGZvY3VzS2V5ID0gZm9jdXNOb2RlLmdldEtleSgpO1xuICBjb25zdCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIGxldCBhbmNob3JET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGFuY2hvcktleSk7XG4gIGxldCBmb2N1c0RPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoZm9jdXNLZXkpO1xuICBsZXQgYW5jaG9yT2Zmc2V0ID0gX2FuY2hvck9mZnNldDtcbiAgbGV0IGZvY3VzT2Zmc2V0ID0gX2ZvY3VzT2Zmc2V0O1xuICBpZiAoJGlzVGV4dE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICBhbmNob3JET00gPSBnZXRET01UZXh0Tm9kZShhbmNob3JET00pO1xuICB9XG4gIGlmICgkaXNUZXh0Tm9kZShmb2N1c05vZGUpKSB7XG4gICAgZm9jdXNET00gPSBnZXRET01UZXh0Tm9kZShmb2N1c0RPTSk7XG4gIH1cbiAgaWYgKGFuY2hvck5vZGUgPT09IHVuZGVmaW5lZCB8fCBmb2N1c05vZGUgPT09IHVuZGVmaW5lZCB8fCBhbmNob3JET00gPT09IG51bGwgfHwgZm9jdXNET00gPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoYW5jaG9yRE9NLm5vZGVOYW1lID09PSAnQlInKSB7XG4gICAgW2FuY2hvckRPTSwgYW5jaG9yT2Zmc2V0XSA9IGdldERPTUluZGV4V2l0aGluUGFyZW50KGFuY2hvckRPTSk7XG4gIH1cbiAgaWYgKGZvY3VzRE9NLm5vZGVOYW1lID09PSAnQlInKSB7XG4gICAgW2ZvY3VzRE9NLCBmb2N1c09mZnNldF0gPSBnZXRET01JbmRleFdpdGhpblBhcmVudChmb2N1c0RPTSk7XG4gIH1cbiAgY29uc3QgZmlyc3RDaGlsZCA9IGFuY2hvckRPTS5maXJzdENoaWxkO1xuICBpZiAoYW5jaG9yRE9NID09PSBmb2N1c0RPTSAmJiBmaXJzdENoaWxkICE9IG51bGwgJiYgZmlyc3RDaGlsZC5ub2RlTmFtZSA9PT0gJ0JSJyAmJiBhbmNob3JPZmZzZXQgPT09IDAgJiYgZm9jdXNPZmZzZXQgPT09IDApIHtcbiAgICBmb2N1c09mZnNldCA9IDE7XG4gIH1cbiAgdHJ5IHtcbiAgICByYW5nZS5zZXRTdGFydChhbmNob3JET00sIGFuY2hvck9mZnNldCk7XG4gICAgcmFuZ2Uuc2V0RW5kKGZvY3VzRE9NLCBmb2N1c09mZnNldCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocmFuZ2UuY29sbGFwc2VkICYmIChhbmNob3JPZmZzZXQgIT09IGZvY3VzT2Zmc2V0IHx8IGFuY2hvcktleSAhPT0gZm9jdXNLZXkpKSB7XG4gICAgLy8gUmFuZ2UgaXMgYmFja3dhcmRzLCB3ZSBuZWVkIHRvIHJldmVyc2UgaXRcbiAgICByYW5nZS5zZXRTdGFydChmb2N1c0RPTSwgZm9jdXNPZmZzZXQpO1xuICAgIHJhbmdlLnNldEVuZChhbmNob3JET00sIGFuY2hvck9mZnNldCk7XG4gIH1cbiAgcmV0dXJuIHJhbmdlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgRE9NUmVjdHMsIGdlbmVyYWxseSB1c2VkIHRvIGhlbHAgdGhlIGVkaXRvciBmaW5kIGEgc3BlY2lmaWMgbG9jYXRpb24gb24gdGhlIHNjcmVlbi5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3JcbiAqIEBwYXJhbSByYW5nZSAtIEEgZnJhZ21lbnQgb2YgYSBkb2N1bWVudCB0aGF0IGNhbiBjb250YWluIG5vZGVzIGFuZCBwYXJ0cyBvZiB0ZXh0IG5vZGVzLlxuICogQHJldHVybnMgVGhlIHNlbGVjdGlvblJlY3RzIGFzIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiBjcmVhdGVSZWN0c0Zyb21ET01SYW5nZShlZGl0b3IsIHJhbmdlKSB7XG4gIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gIGlmIChyb290RWxlbWVudCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCByb290UmVjdCA9IHJvb3RFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShyb290RWxlbWVudCk7XG4gIGNvbnN0IHJvb3RQYWRkaW5nID0gcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdMZWZ0KSArIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQpO1xuICBjb25zdCBzZWxlY3Rpb25SZWN0cyA9IEFycmF5LmZyb20ocmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKSk7XG4gIGxldCBzZWxlY3Rpb25SZWN0c0xlbmd0aCA9IHNlbGVjdGlvblJlY3RzLmxlbmd0aDtcbiAgLy9zb3J0IHJlY3RzIGZyb20gdG9wIGxlZnQgdG8gYm90dG9tIHJpZ2h0LlxuICBzZWxlY3Rpb25SZWN0cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgdG9wID0gYS50b3AgLSBiLnRvcDtcbiAgICAvLyBTb21lIHJlY3RzIG1hdGNoIHBvc2l0aW9uIGNsb3NlbHksIGJ1dCBub3QgcGVyZmVjdGx5LFxuICAgIC8vIHNvIHdlIGdpdmUgYSAzcHggdG9sZXJhbmNlLlxuICAgIGlmIChNYXRoLmFicyh0b3ApIDw9IDMpIHtcbiAgICAgIHJldHVybiBhLmxlZnQgLSBiLmxlZnQ7XG4gICAgfVxuICAgIHJldHVybiB0b3A7XG4gIH0pO1xuICBsZXQgcHJldlJlY3Q7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0aW9uUmVjdHNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlbGVjdGlvblJlY3QgPSBzZWxlY3Rpb25SZWN0c1tpXTtcbiAgICAvLyBFeGNsdWRlIHJlY3RzIHRoYXQgb3ZlcmxhcCBwcmVjZWRpbmcgUmVjdHMgaW4gdGhlIHNvcnRlZCBsaXN0LlxuICAgIGNvbnN0IGlzT3ZlcmxhcHBpbmdSZWN0ID0gcHJldlJlY3QgJiYgcHJldlJlY3QudG9wIDw9IHNlbGVjdGlvblJlY3QudG9wICYmIHByZXZSZWN0LnRvcCArIHByZXZSZWN0LmhlaWdodCA+IHNlbGVjdGlvblJlY3QudG9wICYmIHByZXZSZWN0LmxlZnQgKyBwcmV2UmVjdC53aWR0aCA+IHNlbGVjdGlvblJlY3QubGVmdDtcbiAgICAvLyBFeGNsdWRlIHNlbGVjdGlvbnMgdGhhdCBzcGFuIHRoZSBlbnRpcmUgZWxlbWVudFxuICAgIGNvbnN0IHNlbGVjdGlvblNwYW5zRWxlbWVudCA9IHNlbGVjdGlvblJlY3Qud2lkdGggKyByb290UGFkZGluZyA9PT0gcm9vdFJlY3Qud2lkdGg7XG4gICAgaWYgKGlzT3ZlcmxhcHBpbmdSZWN0IHx8IHNlbGVjdGlvblNwYW5zRWxlbWVudCkge1xuICAgICAgc2VsZWN0aW9uUmVjdHMuc3BsaWNlKGktLSwgMSk7XG4gICAgICBzZWxlY3Rpb25SZWN0c0xlbmd0aC0tO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHByZXZSZWN0ID0gc2VsZWN0aW9uUmVjdDtcbiAgfVxuICByZXR1cm4gc2VsZWN0aW9uUmVjdHM7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHN0eWxlcyBhbmQgdGhlaXIgdmFsdWVzIHByb3ZpZGVkIGluIHRoZSBDU1Mgc3RyaW5nLlxuICogQHBhcmFtIGNzcyAtIFRoZSBDU1Mgc3RyaW5nIG9mIHN0eWxlcyBhbmQgdGhlaXIgdmFsdWVzLlxuICogQHJldHVybnMgVGhlIHN0eWxlT2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBzdHlsZXMgYW5kIHRoZWlyIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVPYmplY3RGcm9tUmF3Q1NTKGNzcykge1xuICBjb25zdCBzdHlsZU9iamVjdCA9IHt9O1xuICBpZiAoIWNzcykge1xuICAgIHJldHVybiBzdHlsZU9iamVjdDtcbiAgfVxuICBjb25zdCBzdHlsZXMgPSBjc3Muc3BsaXQoJzsnKTtcbiAgZm9yIChjb25zdCBzdHlsZSBvZiBzdHlsZXMpIHtcbiAgICBpZiAoc3R5bGUgIT09ICcnKSB7XG4gICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBzdHlsZS5zcGxpdCgvOihbXl0rKS8pOyAvLyBzcGxpdCBvbiBmaXJzdCBjb2xvblxuICAgICAgaWYgKGtleSAmJiB2YWx1ZSkge1xuICAgICAgICBzdHlsZU9iamVjdFtrZXkudHJpbSgpXSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlT2JqZWN0O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgQ1NTIHN0cmluZywgcmV0dXJucyBhbiBvYmplY3QgZnJvbSB0aGUgc3R5bGUgY2FjaGUuXG4gKiBAcGFyYW0gY3NzIC0gVGhlIENTUyBwcm9wZXJ0eSBhcyBhIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gQ1NTIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRTdHlsZU9iamVjdEZyb21DU1MoY3NzKSB7XG4gIGxldCB2YWx1ZSA9IENTU19UT19TVFlMRVMuZ2V0KGNzcyk7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRTdHlsZU9iamVjdEZyb21SYXdDU1MoY3NzKTtcbiAgICBDU1NfVE9fU1RZTEVTLnNldChjc3MsIHZhbHVlKTtcbiAgfVxuICB7XG4gICAgLy8gRnJlZXplIHRoZSB2YWx1ZSBpbiBERVYgdG8gcHJldmVudCBhY2NpZGVudGFsIG11dGF0aW9uc1xuICAgIE9iamVjdC5mcmVlemUodmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBDU1Mgc3R5bGVzIGZyb20gdGhlIHN0eWxlIG9iamVjdC5cbiAqIEBwYXJhbSBzdHlsZXMgLSBUaGUgc3R5bGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHN0eWxlcyB0byBnZXQuXG4gKiBAcmV0dXJucyBBIHN0cmluZyBjb250YWluaW5nIHRoZSBDU1Mgc3R5bGVzIGFuZCB0aGVpciB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldENTU0Zyb21TdHlsZU9iamVjdChzdHlsZXMpIHtcbiAgbGV0IGNzcyA9ICcnO1xuICBmb3IgKGNvbnN0IHN0eWxlIGluIHN0eWxlcykge1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgY3NzICs9IGAke3N0eWxlfTogJHtzdHlsZXNbc3R5bGVdfTtgO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3NzO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogR2VuZXJhbGx5IHVzZWQgdG8gYXBwZW5kIHRleHQgY29udGVudCB0byBIVE1MIGFuZCBKU09OLiBHcmFicyB0aGUgdGV4dCBjb250ZW50IGFuZCBcInNsaWNlc1wiXG4gKiBpdCB0byBiZSBnZW5lcmF0ZWQgaW50byB0aGUgbmV3IFRleHROb2RlLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gY29udGFpbmluZyB0aGUgbm9kZSB3aG9zZSBUZXh0Tm9kZSBpcyB0byBiZSBlZGl0ZWQuXG4gKiBAcGFyYW0gdGV4dE5vZGUgLSBUaGUgVGV4dE5vZGUgdG8gYmUgZWRpdGVkLlxuICogQHJldHVybnMgVGhlIHVwZGF0ZWQgVGV4dE5vZGUuXG4gKi9cbmZ1bmN0aW9uICRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50KHNlbGVjdGlvbiwgdGV4dE5vZGUpIHtcbiAgY29uc3QgYW5jaG9yQW5kRm9jdXMgPSBzZWxlY3Rpb24uZ2V0U3RhcnRFbmRQb2ludHMoKTtcbiAgaWYgKHRleHROb2RlLmlzU2VsZWN0ZWQoc2VsZWN0aW9uKSAmJiAhdGV4dE5vZGUuaXNTZWdtZW50ZWQoKSAmJiAhdGV4dE5vZGUuaXNUb2tlbigpICYmIGFuY2hvckFuZEZvY3VzICE9PSBudWxsKSB7XG4gICAgY29uc3QgW2FuY2hvciwgZm9jdXNdID0gYW5jaG9yQW5kRm9jdXM7XG4gICAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGlzQW5jaG9yID0gdGV4dE5vZGUuaXMoYW5jaG9yTm9kZSk7XG4gICAgY29uc3QgaXNGb2N1cyA9IHRleHROb2RlLmlzKGZvY3VzTm9kZSk7XG4gICAgaWYgKGlzQW5jaG9yIHx8IGlzRm9jdXMpIHtcbiAgICAgIGNvbnN0IFthbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0XSA9ICRnZXRDaGFyYWN0ZXJPZmZzZXRzKHNlbGVjdGlvbik7XG4gICAgICBjb25zdCBpc1NhbWUgPSBhbmNob3JOb2RlLmlzKGZvY3VzTm9kZSk7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gdGV4dE5vZGUuaXMoaXNCYWNrd2FyZCA/IGZvY3VzTm9kZSA6IGFuY2hvck5vZGUpO1xuICAgICAgY29uc3QgaXNMYXN0ID0gdGV4dE5vZGUuaXMoaXNCYWNrd2FyZCA/IGFuY2hvck5vZGUgOiBmb2N1c05vZGUpO1xuICAgICAgbGV0IHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgIGxldCBlbmRPZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoaXNTYW1lKSB7XG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gYW5jaG9yT2Zmc2V0ID4gZm9jdXNPZmZzZXQgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgICAgICAgZW5kT2Zmc2V0ID0gYW5jaG9yT2Zmc2V0ID4gZm9jdXNPZmZzZXQgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcbiAgICAgIH0gZWxzZSBpZiAoaXNGaXJzdCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpc0JhY2t3YXJkID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBlbmRPZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKGlzTGFzdCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpc0JhY2t3YXJkID8gYW5jaG9yT2Zmc2V0IDogZm9jdXNPZmZzZXQ7XG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgZW5kT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgfVxuICAgICAgdGV4dE5vZGUuX190ZXh0ID0gdGV4dE5vZGUuX190ZXh0LnNsaWNlKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgcmV0dXJuIHRleHROb2RlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dE5vZGU7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgYXQgdGhlIGVuZCBvZiB0aGUgbm9kZS5cbiAqIEBwYXJhbSBwb2ludCAtIFRoZSBwb2ludCBvZiB0aGUgc2VsZWN0aW9uIHRvIHRlc3QuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBwb2ludCBvZmZzZXQgaXMgaW4gdGhlIGxhc3QgcG9zc2libGUgcG9zaXRpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gJGlzQXROb2RlRW5kKHBvaW50KSB7XG4gIGlmIChwb2ludC50eXBlID09PSAndGV4dCcpIHtcbiAgICByZXR1cm4gcG9pbnQub2Zmc2V0ID09PSBwb2ludC5nZXROb2RlKCkuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gIH1cbiAgY29uc3Qgbm9kZSA9IHBvaW50LmdldE5vZGUoKTtcbiAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIHRocm93IEVycm9yKGBpc0F0Tm9kZUVuZDogbm9kZSBtdXN0IGJlIGEgVGV4dE5vZGUgb3IgRWxlbWVudE5vZGVgKTtcbiAgfVxuICByZXR1cm4gcG9pbnQub2Zmc2V0ID09PSBub2RlLmdldENoaWxkcmVuU2l6ZSgpO1xufVxuXG4vKipcbiAqIFRyaW1zIHRleHQgZnJvbSBhIG5vZGUgaW4gb3JkZXIgdG8gc2hvcnRlbiBpdCwgZWcuIHRvIGVuZm9yY2UgYSB0ZXh0J3MgbWF4IGxlbmd0aC4gSWYgaXQgZGVsZXRlcyB0ZXh0XG4gKiB0aGF0IGlzIGFuIGFuY2VzdG9yIG9mIHRoZSBhbmNob3IgdGhlbiBpdCB3aWxsIGxlYXZlIDIgaW5kZW50cywgb3RoZXJ3aXNlLCBpZiBubyB0ZXh0IGNvbnRlbnQgZXhpc3RzLCBpdCBkZWxldGVzXG4gKiB0aGUgVGV4dE5vZGUuIEl0IHdpbGwgbW92ZSB0aGUgZm9jdXMgdG8gZWl0aGVyIHRoZSBlbmQgb2YgYW55IGxlZnQgb3ZlciB0ZXh0IG9yIGJlZ2lubmluZyBvZiBhIG5ldyBUZXh0Tm9kZS5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3IuXG4gKiBAcGFyYW0gYW5jaG9yIC0gVGhlIGFuY2hvciBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24sIHdoZXJlIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIHBvaW50aW5nLlxuICogQHBhcmFtIGRlbENvdW50IC0gVGhlIGFtb3VudCBvZiBjaGFyYWN0ZXJzIHRvIGRlbGV0ZS4gVXNlZnVsIGFzIGEgZHluYW1pYyB2YXJpYWJsZSBlZy4gdGV4dENvbnRlbnRTaXplIC0gbWF4TGVuZ3RoO1xuICovXG5mdW5jdGlvbiAkdHJpbVRleHRDb250ZW50RnJvbUFuY2hvcihlZGl0b3IsIGFuY2hvciwgZGVsQ291bnQpIHtcbiAgLy8gV29yayBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBhbmNob3IgcG9pbnRcbiAgbGV0IGN1cnJlbnROb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgbGV0IHJlbWFpbmluZyA9IGRlbENvdW50O1xuICBpZiAoJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgY29uc3QgZGVzY2VuZGFudE5vZGUgPSBjdXJyZW50Tm9kZS5nZXREZXNjZW5kYW50QnlJbmRleChhbmNob3Iub2Zmc2V0KTtcbiAgICBpZiAoZGVzY2VuZGFudE5vZGUgIT09IG51bGwpIHtcbiAgICAgIGN1cnJlbnROb2RlID0gZGVzY2VuZGFudE5vZGU7XG4gICAgfVxuICB9XG4gIHdoaWxlIChyZW1haW5pbmcgPiAwICYmIGN1cnJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSkge1xuICAgICAgY29uc3QgbGFzdERlc2NlbmRhbnQgPSBjdXJyZW50Tm9kZS5nZXRMYXN0RGVzY2VuZGFudCgpO1xuICAgICAgaWYgKGxhc3REZXNjZW5kYW50ICE9PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnROb2RlID0gbGFzdERlc2NlbmRhbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBuZXh0Tm9kZSA9IGN1cnJlbnROb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGxldCBhZGRpdGlvbmFsRWxlbWVudFdoaXRlc3BhY2UgPSAwO1xuICAgIGlmIChuZXh0Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgbGV0IHBhcmVudCA9IGN1cnJlbnROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGxldCBwYXJlbnRTaWJsaW5nID0gcGFyZW50LmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgd2hpbGUgKHBhcmVudFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudFNpYmxpbmcgPSBwYXJlbnQuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGFkZGl0aW9uYWxFbGVtZW50V2hpdGVzcGFjZSA9IHBhcmVudC5pc0lubGluZSgpID8gMCA6IDI7XG4gICAgICAgIG5leHROb2RlID0gcGFyZW50U2libGluZztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHRleHQgPSBjdXJyZW50Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIC8vIElmIHRoZSB0ZXh0IGlzIGVtcHR5LCB3ZSBuZWVkIHRvIGNvbnNpZGVyIGFkZGluZyBpbiB0d28gbGluZSBicmVha3MgdG8gbWF0Y2hcbiAgICAvLyB0aGUgY29udGVudCBpZiB3ZSB3ZXJlIHRvIGdldCBpdCBmcm9tIGl0cyBwYXJlbnQuXG4gICAgaWYgKHRleHQgPT09ICcnICYmICRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiAhY3VycmVudE5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgYmUgaGFuZGxlZCBpbiBjb3JlP1xuICAgICAgdGV4dCA9ICdcXG5cXG4nO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50Tm9kZVNpemUgPSB0ZXh0Lmxlbmd0aDtcbiAgICBpZiAoISRpc1RleHROb2RlKGN1cnJlbnROb2RlKSB8fCByZW1haW5pbmcgPj0gY3VycmVudE5vZGVTaXplKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBjdXJyZW50Tm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGN1cnJlbnROb2RlLnJlbW92ZSgpO1xuICAgICAgaWYgKHBhcmVudCAhPSBudWxsICYmIHBhcmVudC5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCAmJiAhJGlzUm9vdE5vZGUocGFyZW50KSkge1xuICAgICAgICBwYXJlbnQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICByZW1haW5pbmcgLT0gY3VycmVudE5vZGVTaXplICsgYWRkaXRpb25hbEVsZW1lbnRXaGl0ZXNwYWNlO1xuICAgICAgY3VycmVudE5vZGUgPSBuZXh0Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qga2V5ID0gY3VycmVudE5vZGUuZ2V0S2V5KCk7XG4gICAgICAvLyBTZWUgaWYgd2UgY2FuIGp1c3QgcmV2ZXJ0IGl0IHRvIHdoYXQgd2FzIGluIHRoZSBsYXN0IGVkaXRvciBzdGF0ZVxuICAgICAgY29uc3QgcHJldlRleHRDb250ZW50ID0gZWRpdG9yLmdldEVkaXRvclN0YXRlKCkucmVhZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZOb2RlID0gJGdldE5vZGVCeUtleShrZXkpO1xuICAgICAgICBpZiAoJGlzVGV4dE5vZGUocHJldk5vZGUpICYmIHByZXZOb2RlLmlzU2ltcGxlVGV4dCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXZOb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGN1cnJlbnROb2RlU2l6ZSAtIHJlbWFpbmluZztcbiAgICAgIGNvbnN0IHNsaWNlZFRleHQgPSB0ZXh0LnNsaWNlKDAsIG9mZnNldCk7XG4gICAgICBpZiAocHJldlRleHRDb250ZW50ICE9PSBudWxsICYmIHByZXZUZXh0Q29udGVudCAhPT0gdGV4dCkge1xuICAgICAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gICAgICAgIGxldCB0YXJnZXQgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgaWYgKCFjdXJyZW50Tm9kZS5pc1NpbXBsZVRleHQoKSkge1xuICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKHByZXZUZXh0Q29udGVudCk7XG4gICAgICAgICAgY3VycmVudE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICAgICAgdGFyZ2V0ID0gdGV4dE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudE5vZGUuc2V0VGV4dENvbnRlbnQocHJldlRleHRDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgcHJldlNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgICAgY29uc3QgcHJldk9mZnNldCA9IHByZXZTZWxlY3Rpb24uYW5jaG9yLm9mZnNldDtcbiAgICAgICAgICB0YXJnZXQuc2VsZWN0KHByZXZPZmZzZXQsIHByZXZPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnROb2RlLmlzU2ltcGxlVGV4dCgpKSB7XG4gICAgICAgIC8vIFNwbGl0IHRleHRcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IGFuY2hvci5rZXkgPT09IGtleTtcbiAgICAgICAgbGV0IGFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgICAgIC8vIE1vdmUgb2Zmc2V0IHRvIGVuZCBpZiBpdCdzIGxlc3MgdGhhbiB0aGUgcmVtYWluaW5nIG51bWJlciwgb3RoZXJ3aXNlXG4gICAgICAgIC8vIHdlJ2xsIGhhdmUgYSBuZWdhdGl2ZSBzcGxpdFN0YXJ0LlxuICAgICAgICBpZiAoYW5jaG9yT2Zmc2V0IDwgcmVtYWluaW5nKSB7XG4gICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gY3VycmVudE5vZGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwbGl0U3RhcnQgPSBpc1NlbGVjdGVkID8gYW5jaG9yT2Zmc2V0IC0gcmVtYWluaW5nIDogMDtcbiAgICAgICAgY29uc3Qgc3BsaXRFbmQgPSBpc1NlbGVjdGVkID8gYW5jaG9yT2Zmc2V0IDogb2Zmc2V0O1xuICAgICAgICBpZiAoaXNTZWxlY3RlZCAmJiBzcGxpdFN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgY29uc3QgW2V4Y2Vzc05vZGVdID0gY3VycmVudE5vZGUuc3BsaXRUZXh0KHNwbGl0U3RhcnQsIHNwbGl0RW5kKTtcbiAgICAgICAgICBleGNlc3NOb2RlLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IFssIGV4Y2Vzc05vZGVdID0gY3VycmVudE5vZGUuc3BsaXRUZXh0KHNwbGl0U3RhcnQsIHNwbGl0RW5kKTtcbiAgICAgICAgICBleGNlc3NOb2RlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShzbGljZWRUZXh0KTtcbiAgICAgICAgY3VycmVudE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICB9XG4gICAgICByZW1haW5pbmcgPSAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIFRleHROb2RlJ3Mgc3R5bGUgb2JqZWN0IGFuZCBhZGRzIHRoZSBzdHlsZXMgdG8gdGhlIENTUy5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIFRleHROb2RlIHRvIGFkZCBzdHlsZXMgdG8uXG4gKi9cbmZ1bmN0aW9uICRhZGROb2RlU3R5bGUobm9kZSkge1xuICBjb25zdCBDU1NUZXh0ID0gbm9kZS5nZXRTdHlsZSgpO1xuICBjb25zdCBzdHlsZXMgPSBnZXRTdHlsZU9iamVjdEZyb21SYXdDU1MoQ1NTVGV4dCk7XG4gIENTU19UT19TVFlMRVMuc2V0KENTU1RleHQsIHN0eWxlcyk7XG59XG5mdW5jdGlvbiAkcGF0Y2hTdHlsZSh0YXJnZXQsIHBhdGNoKSB7XG4gIGNvbnN0IHByZXZTdHlsZXMgPSBnZXRTdHlsZU9iamVjdEZyb21DU1MoJ2dldFN0eWxlJyBpbiB0YXJnZXQgPyB0YXJnZXQuZ2V0U3R5bGUoKSA6IHRhcmdldC5zdHlsZSk7XG4gIGNvbnN0IG5ld1N0eWxlcyA9IE9iamVjdC5lbnRyaWVzKHBhdGNoKS5yZWR1Y2UoKHN0eWxlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3R5bGVzW2tleV0gPSB2YWx1ZShwcmV2U3R5bGVzW2tleV0sIHRhcmdldCk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgZGVsZXRlIHN0eWxlc1trZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzO1xuICB9LCB7XG4gICAgLi4ucHJldlN0eWxlc1xuICB9IHx8IHt9KTtcbiAgY29uc3QgbmV3Q1NTVGV4dCA9IGdldENTU0Zyb21TdHlsZU9iamVjdChuZXdTdHlsZXMpO1xuICB0YXJnZXQuc2V0U3R5bGUobmV3Q1NTVGV4dCk7XG4gIENTU19UT19TVFlMRVMuc2V0KG5ld0NTU1RleHQsIG5ld1N0eWxlcyk7XG59XG5cbi8qKlxuICogQXBwbGllcyB0aGUgcHJvdmlkZWQgc3R5bGVzIHRvIHRoZSBUZXh0Tm9kZXMgaW4gdGhlIHByb3ZpZGVkIFNlbGVjdGlvbi5cbiAqIFdpbGwgdXBkYXRlIHBhcnRpYWxseSBzZWxlY3RlZCBUZXh0Tm9kZXMgYnkgc3BsaXR0aW5nIHRoZSBUZXh0Tm9kZSBhbmQgYXBwbHlpbmdcbiAqIHRoZSBzdHlsZXMgdG8gdGhlIGFwcHJvcHJpYXRlIG9uZS5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0ZWQgbm9kZShzKSB0byB1cGRhdGUuXG4gKiBAcGFyYW0gcGF0Y2ggLSBUaGUgcGF0Y2ggdG8gYXBwbHksIHdoaWNoIGNhbiBpbmNsdWRlIG11bHRpcGxlIHN0eWxlcy4gXFxcXHtDU1NQcm9wZXJ0eTogdmFsdWVcXFxcfSAuIENhbiBhbHNvIGFjY2VwdCBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV3IHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiAkcGF0Y2hTdHlsZVRleHQoc2VsZWN0aW9uLCBwYXRjaCkge1xuICBjb25zdCBzZWxlY3RlZE5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGNvbnN0IHNlbGVjdGVkTm9kZXNMZW5ndGggPSBzZWxlY3RlZE5vZGVzLmxlbmd0aDtcbiAgY29uc3QgYW5jaG9yQW5kRm9jdXMgPSBzZWxlY3Rpb24uZ2V0U3RhcnRFbmRQb2ludHMoKTtcbiAgaWYgKGFuY2hvckFuZEZvY3VzID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IFthbmNob3IsIGZvY3VzXSA9IGFuY2hvckFuZEZvY3VzO1xuICBjb25zdCBsYXN0SW5kZXggPSBzZWxlY3RlZE5vZGVzTGVuZ3RoIC0gMTtcbiAgbGV0IGZpcnN0Tm9kZSA9IHNlbGVjdGVkTm9kZXNbMF07XG4gIGxldCBsYXN0Tm9kZSA9IHNlbGVjdGVkTm9kZXNbbGFzdEluZGV4XTtcbiAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAkcGF0Y2hTdHlsZShzZWxlY3Rpb24sIHBhdGNoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZmlyc3ROb2RlVGV4dCA9IGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICBjb25zdCBmaXJzdE5vZGVUZXh0TGVuZ3RoID0gZmlyc3ROb2RlVGV4dC5sZW5ndGg7XG4gIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICBsZXQgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgaXNCZWZvcmUgPSBhbmNob3IuaXNCZWZvcmUoZm9jdXMpO1xuICBsZXQgc3RhcnRPZmZzZXQgPSBpc0JlZm9yZSA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICBsZXQgZW5kT2Zmc2V0ID0gaXNCZWZvcmUgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgY29uc3Qgc3RhcnRUeXBlID0gaXNCZWZvcmUgPyBhbmNob3IudHlwZSA6IGZvY3VzLnR5cGU7XG4gIGNvbnN0IGVuZFR5cGUgPSBpc0JlZm9yZSA/IGZvY3VzLnR5cGUgOiBhbmNob3IudHlwZTtcbiAgY29uc3QgZW5kS2V5ID0gaXNCZWZvcmUgPyBmb2N1cy5rZXkgOiBhbmNob3Iua2V5O1xuXG4gIC8vIFRoaXMgaXMgdGhlIGNhc2Ugd2hlcmUgdGhlIHVzZXIgb25seSBzZWxlY3RlZCB0aGUgdmVyeSBlbmQgb2YgdGhlXG4gIC8vIGZpcnN0IG5vZGUgc28gd2UgZG9uJ3Qgd2FudCB0byBpbmNsdWRlIGl0IGluIHRoZSBmb3JtYXR0aW5nIGNoYW5nZS5cbiAgaWYgKCRpc1RleHROb2RlKGZpcnN0Tm9kZSkgJiYgc3RhcnRPZmZzZXQgPT09IGZpcnN0Tm9kZVRleHRMZW5ndGgpIHtcbiAgICBjb25zdCBuZXh0U2libGluZyA9IGZpcnN0Tm9kZS5nZXROZXh0U2libGluZygpO1xuICAgIGlmICgkaXNUZXh0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgIC8vIHdlIGJhc2ljYWxseSBtYWtlIHRoZSBzZWNvbmQgbm9kZSB0aGUgZmlyc3ROb2RlLCBjaGFuZ2luZyBvZmZzZXRzIGFjY29yZGluZ2x5XG4gICAgICBhbmNob3JPZmZzZXQgPSAwO1xuICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgZmlyc3ROb2RlID0gbmV4dFNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhpcyBpcyB0aGUgY2FzZSB3aGVyZSB3ZSBvbmx5IHNlbGVjdGVkIGEgc2luZ2xlIG5vZGVcbiAgaWYgKHNlbGVjdGVkTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKCRpc1RleHROb2RlKGZpcnN0Tm9kZSkgJiYgZmlyc3ROb2RlLmNhbkhhdmVGb3JtYXQoKSkge1xuICAgICAgc3RhcnRPZmZzZXQgPSBzdGFydFR5cGUgPT09ICdlbGVtZW50JyA/IDAgOiBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICAgICAgZW5kT2Zmc2V0ID0gZW5kVHlwZSA9PT0gJ2VsZW1lbnQnID8gZmlyc3ROb2RlVGV4dExlbmd0aCA6IGFuY2hvck9mZnNldCA+IGZvY3VzT2Zmc2V0ID8gYW5jaG9yT2Zmc2V0IDogZm9jdXNPZmZzZXQ7XG5cbiAgICAgIC8vIE5vIGFjdHVhbCB0ZXh0IGlzIHNlbGVjdGVkLCBzbyBkbyBub3RoaW5nLlxuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSBlbmRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgZW50aXJlIG5vZGUgaXMgc2VsZWN0ZWQgb3IgYSB0b2tlbi9zZWdtZW50LCBzbyBqdXN0IGZvcm1hdCBpdFxuICAgICAgaWYgKCRpc1Rva2VuT3JTZWdtZW50ZWQoZmlyc3ROb2RlKSB8fCBzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXQgPT09IGZpcnN0Tm9kZVRleHRMZW5ndGgpIHtcbiAgICAgICAgJHBhdGNoU3R5bGUoZmlyc3ROb2RlLCBwYXRjaCk7XG4gICAgICAgIGZpcnN0Tm9kZS5zZWxlY3Qoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgbm9kZSBpcyBwYXJ0aWFsbHkgc2VsZWN0ZWQsIHNvIHNwbGl0IGl0IGludG8gdHdvIG5vZGVzXG4gICAgICAgIC8vIGFuZCBzdHlsZSB0aGUgc2VsZWN0ZWQgb25lLlxuICAgICAgICBjb25zdCBzcGxpdE5vZGVzID0gZmlyc3ROb2RlLnNwbGl0VGV4dChzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBzdGFydE9mZnNldCA9PT0gMCA/IHNwbGl0Tm9kZXNbMF0gOiBzcGxpdE5vZGVzWzFdO1xuICAgICAgICAkcGF0Y2hTdHlsZShyZXBsYWNlbWVudCwgcGF0Y2gpO1xuICAgICAgICByZXBsYWNlbWVudC5zZWxlY3QoMCwgZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQpO1xuICAgICAgfVxuICAgIH0gLy8gbXVsdGlwbGUgbm9kZXMgc2VsZWN0ZWQuXG4gIH0gZWxzZSB7XG4gICAgaWYgKCRpc1RleHROb2RlKGZpcnN0Tm9kZSkgJiYgc3RhcnRPZmZzZXQgPCBmaXJzdE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkgJiYgZmlyc3ROb2RlLmNhbkhhdmVGb3JtYXQoKSkge1xuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ICE9PSAwICYmICEkaXNUb2tlbk9yU2VnbWVudGVkKGZpcnN0Tm9kZSkpIHtcbiAgICAgICAgLy8gdGhlIGVudGlyZSBmaXJzdCBub2RlIGlzbid0IHNlbGVjdGVkIGFuZCBpdCBpc24ndCBhIHRva2VuIG9yIHNlZ21lbnRlZCwgc28gc3BsaXQgaXRcbiAgICAgICAgZmlyc3ROb2RlID0gZmlyc3ROb2RlLnNwbGl0VGV4dChzdGFydE9mZnNldClbMV07XG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKGlzQmVmb3JlKSB7XG4gICAgICAgICAgYW5jaG9yLnNldChmaXJzdE5vZGUuZ2V0S2V5KCksIHN0YXJ0T2Zmc2V0LCAndGV4dCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvY3VzLnNldChmaXJzdE5vZGUuZ2V0S2V5KCksIHN0YXJ0T2Zmc2V0LCAndGV4dCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAkcGF0Y2hTdHlsZShmaXJzdE5vZGUsIHBhdGNoKTtcbiAgICB9XG4gICAgaWYgKCRpc1RleHROb2RlKGxhc3ROb2RlKSAmJiBsYXN0Tm9kZS5jYW5IYXZlRm9ybWF0KCkpIHtcbiAgICAgIGNvbnN0IGxhc3ROb2RlVGV4dCA9IGxhc3ROb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICBjb25zdCBsYXN0Tm9kZVRleHRMZW5ndGggPSBsYXN0Tm9kZVRleHQubGVuZ3RoO1xuXG4gICAgICAvLyBUaGUgbGFzdCBub2RlIG1pZ2h0IG5vdCBhY3R1YWxseSBiZSB0aGUgZW5kIG5vZGVcbiAgICAgIC8vXG4gICAgICAvLyBJZiBub3QsIGFzc3VtZSB0aGUgbGFzdCBub2RlIGlzIGZ1bGx5LXNlbGVjdGVkIHVubGVzcyB0aGUgZW5kIG9mZnNldCBpc1xuICAgICAgLy8gemVyby5cbiAgICAgIGlmIChsYXN0Tm9kZS5fX2tleSAhPT0gZW5kS2V5ICYmIGVuZE9mZnNldCAhPT0gMCkge1xuICAgICAgICBlbmRPZmZzZXQgPSBsYXN0Tm9kZVRleHRMZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZSBlbnRpcmUgbGFzdCBub2RlIGlzbid0IHNlbGVjdGVkIGFuZCBpdCBpc24ndCBhIHRva2VuIG9yIHNlZ21lbnRlZCwgc3BsaXQgaXRcbiAgICAgIGlmIChlbmRPZmZzZXQgIT09IGxhc3ROb2RlVGV4dExlbmd0aCAmJiAhJGlzVG9rZW5PclNlZ21lbnRlZChsYXN0Tm9kZSkpIHtcbiAgICAgICAgW2xhc3ROb2RlXSA9IGxhc3ROb2RlLnNwbGl0VGV4dChlbmRPZmZzZXQpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZE9mZnNldCAhPT0gMCB8fCBlbmRUeXBlID09PSAnZWxlbWVudCcpIHtcbiAgICAgICAgJHBhdGNoU3R5bGUobGFzdE5vZGUsIHBhdGNoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdHlsZSBhbGwgdGhlIHRleHQgbm9kZXMgaW4gYmV0d2VlblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGFzdEluZGV4OyBpKyspIHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZSA9IHNlbGVjdGVkTm9kZXNbaV07XG4gICAgICBjb25zdCBzZWxlY3RlZE5vZGVLZXkgPSBzZWxlY3RlZE5vZGUuZ2V0S2V5KCk7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUoc2VsZWN0ZWROb2RlKSAmJiBzZWxlY3RlZE5vZGUuY2FuSGF2ZUZvcm1hdCgpICYmIHNlbGVjdGVkTm9kZUtleSAhPT0gZmlyc3ROb2RlLmdldEtleSgpICYmIHNlbGVjdGVkTm9kZUtleSAhPT0gbGFzdE5vZGUuZ2V0S2V5KCkgJiYgIXNlbGVjdGVkTm9kZS5pc1Rva2VuKCkpIHtcbiAgICAgICAgJHBhdGNoU3R5bGUoc2VsZWN0ZWROb2RlLCBwYXRjaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vKipcbiAqIENvbnZlcnRzIGFsbCBub2RlcyBpbiB0aGUgc2VsZWN0aW9uIHRoYXQgYXJlIG9mIG9uZSBibG9jayB0eXBlIHRvIGFub3RoZXIuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGVkIGJsb2NrcyB0byBiZSBjb252ZXJ0ZWQuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudCAtIFRoZSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlIG5vZGUuIGVnLiAkY3JlYXRlUGFyYWdyYXBoTm9kZS5cbiAqL1xuZnVuY3Rpb24gJHNldEJsb2Nrc1R5cGUoc2VsZWN0aW9uLCBjcmVhdGVFbGVtZW50KSB7XG4gIGlmIChzZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYW5jaG9yQW5kRm9jdXMgPSBzZWxlY3Rpb24uZ2V0U3RhcnRFbmRQb2ludHMoKTtcbiAgY29uc3QgYW5jaG9yID0gYW5jaG9yQW5kRm9jdXMgPyBhbmNob3JBbmRGb2N1c1swXSA6IG51bGw7XG4gIGlmIChhbmNob3IgIT09IG51bGwgJiYgYW5jaG9yLmtleSA9PT0gJ3Jvb3QnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gcm9vdC5nZXRGaXJzdENoaWxkKCk7XG4gICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgIGZpcnN0Q2hpbGQucmVwbGFjZShlbGVtZW50LCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdC5hcHBlbmQoZWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBjb25zdCBmaXJzdFNlbGVjdGVkQmxvY2sgPSBhbmNob3IgIT09IG51bGwgPyAkZ2V0QW5jZXN0b3IoYW5jaG9yLmdldE5vZGUoKSwgSU5URVJOQUxfJGlzQmxvY2spIDogZmFsc2U7XG4gIGlmIChmaXJzdFNlbGVjdGVkQmxvY2sgJiYgbm9kZXMuaW5kZXhPZihmaXJzdFNlbGVjdGVkQmxvY2spID09PSAtMSkge1xuICAgIG5vZGVzLnB1c2goZmlyc3RTZWxlY3RlZEJsb2NrKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICghSU5URVJOQUxfJGlzQmxvY2sobm9kZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgYmxvY2sgbm9kZSB0byBiZSBhbiBFbGVtZW50Tm9kZWApO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gY3JlYXRlRWxlbWVudCgpO1xuICAgIHRhcmdldEVsZW1lbnQuc2V0Rm9ybWF0KG5vZGUuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgICB0YXJnZXRFbGVtZW50LnNldEluZGVudChub2RlLmdldEluZGVudCgpKTtcbiAgICBub2RlLnJlcGxhY2UodGFyZ2V0RWxlbWVudCwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzUG9pbnRBdHRhY2hlZChwb2ludCkge1xuICByZXR1cm4gcG9pbnQuZ2V0Tm9kZSgpLmlzQXR0YWNoZWQoKTtcbn1cbmZ1bmN0aW9uICRyZW1vdmVQYXJlbnRFbXB0eUVsZW1lbnRzKHN0YXJ0aW5nTm9kZSkge1xuICBsZXQgbm9kZSA9IHN0YXJ0aW5nTm9kZTtcbiAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgISRpc1Jvb3RPclNoYWRvd1Jvb3Qobm9kZSkpIHtcbiAgICBjb25zdCBsYXRlc3QgPSBub2RlLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIGlmIChsYXRlc3QuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICAgIG5vZGUucmVtb3ZlKHRydWUpO1xuICAgIH1cbiAgICBub2RlID0gcGFyZW50Tm9kZTtcbiAgfVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBXcmFwcyBhbGwgbm9kZXMgaW4gdGhlIHNlbGVjdGlvbiBpbnRvIGFub3RoZXIgbm9kZSBvZiB0aGUgdHlwZSByZXR1cm5lZCBieSBjcmVhdGVFbGVtZW50LlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gb2Ygbm9kZXMgdG8gYmUgd3JhcHBlZC5cbiAqIEBwYXJhbSBjcmVhdGVFbGVtZW50IC0gQSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlIHdyYXBwaW5nIEVsZW1lbnROb2RlLiBlZy4gJGNyZWF0ZVBhcmFncmFwaE5vZGUuXG4gKiBAcGFyYW0gd3JhcHBpbmdFbGVtZW50IC0gQW4gZWxlbWVudCB0byBhcHBlbmQgdGhlIHdyYXBwZWQgc2VsZWN0aW9uIGFuZCBpdHMgY2hpbGRyZW4gdG8uXG4gKi9cbmZ1bmN0aW9uICR3cmFwTm9kZXMoc2VsZWN0aW9uLCBjcmVhdGVFbGVtZW50LCB3cmFwcGluZ0VsZW1lbnQgPSBudWxsKSB7XG4gIGNvbnN0IGFuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uLmdldFN0YXJ0RW5kUG9pbnRzKCk7XG4gIGNvbnN0IGFuY2hvciA9IGFuY2hvckFuZEZvY3VzID8gYW5jaG9yQW5kRm9jdXNbMF0gOiBudWxsO1xuICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBjb25zdCBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcbiAgaWYgKGFuY2hvciAhPT0gbnVsbCAmJiAobm9kZXNMZW5ndGggPT09IDAgfHwgbm9kZXNMZW5ndGggPT09IDEgJiYgYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiBhbmNob3IuZ2V0Tm9kZSgpLmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSkge1xuICAgIGNvbnN0IHRhcmdldCA9IGFuY2hvci50eXBlID09PSAndGV4dCcgPyBhbmNob3IuZ2V0Tm9kZSgpLmdldFBhcmVudE9yVGhyb3coKSA6IGFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0YXJnZXQuZ2V0Q2hpbGRyZW4oKTtcbiAgICBsZXQgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICBlbGVtZW50LnNldEZvcm1hdCh0YXJnZXQuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgICBlbGVtZW50LnNldEluZGVudCh0YXJnZXQuZ2V0SW5kZW50KCkpO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gZWxlbWVudC5hcHBlbmQoY2hpbGQpKTtcbiAgICBpZiAod3JhcHBpbmdFbGVtZW50KSB7XG4gICAgICBlbGVtZW50ID0gd3JhcHBpbmdFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcbiAgICB9XG4gICAgdGFyZ2V0LnJlcGxhY2UoZWxlbWVudCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCB0b3BMZXZlbE5vZGUgPSBudWxsO1xuICBsZXQgZGVzY2VuZGFudHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIC8vIERldGVybWluZSB3aGV0aGVyIHdyYXBwaW5nIGhhcyB0byBiZSBicm9rZW4gZG93biBpbnRvIG11bHRpcGxlIGNodW5rcy4gVGhpcyBjYW4gaGFwcGVuIGlmIHRoZVxuICAgIC8vIHVzZXIgc2VsZWN0ZWQgbXVsdGlwbGUgUm9vdC1saWtlIG5vZGVzIHRoYXQgaGF2ZSB0byBiZSB0cmVhdGVkIHNlcGFyYXRlbHkgYXMgaWYgdGhleSBhcmVcbiAgICAvLyB0aGVpciBvd24gYnJhbmNoLiBJLmUuIHlvdSBkb24ndCB3YW50IHRvIHdyYXAgYSB3aG9sZSB0YWJsZSwgYnV0IHJhdGhlciB0aGUgY29udGVudHMgb2YgZWFjaFxuICAgIC8vIG9mIGVhY2ggb2YgdGhlIGNlbGwgbm9kZXMuXG4gICAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3Qobm9kZSkpIHtcbiAgICAgICR3cmFwTm9kZXNJbXBsKHNlbGVjdGlvbiwgZGVzY2VuZGFudHMsIGRlc2NlbmRhbnRzLmxlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50KTtcbiAgICAgIGRlc2NlbmRhbnRzID0gW107XG4gICAgICB0b3BMZXZlbE5vZGUgPSBub2RlO1xuICAgIH0gZWxzZSBpZiAodG9wTGV2ZWxOb2RlID09PSBudWxsIHx8IHRvcExldmVsTm9kZSAhPT0gbnVsbCAmJiAkaGFzQW5jZXN0b3Iobm9kZSwgdG9wTGV2ZWxOb2RlKSkge1xuICAgICAgZGVzY2VuZGFudHMucHVzaChub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHdyYXBOb2Rlc0ltcGwoc2VsZWN0aW9uLCBkZXNjZW5kYW50cywgZGVzY2VuZGFudHMubGVuZ3RoLCBjcmVhdGVFbGVtZW50LCB3cmFwcGluZ0VsZW1lbnQpO1xuICAgICAgZGVzY2VuZGFudHMgPSBbbm9kZV07XG4gICAgfVxuICB9XG4gICR3cmFwTm9kZXNJbXBsKHNlbGVjdGlvbiwgZGVzY2VuZGFudHMsIGRlc2NlbmRhbnRzLmxlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50KTtcbn1cblxuLyoqXG4gKiBXcmFwcyBlYWNoIG5vZGUgaW50byBhIG5ldyBFbGVtZW50Tm9kZS5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIG9mIG5vZGVzIHRvIHdyYXAuXG4gKiBAcGFyYW0gbm9kZXMgLSBBbiBhcnJheSBvZiBub2RlcywgZ2VuZXJhbGx5IHRoZSBkZXNjZW5kYW50cyBvZiB0aGUgc2VsZWN0aW9uLlxuICogQHBhcmFtIG5vZGVzTGVuZ3RoIC0gVGhlIGxlbmd0aCBvZiBub2Rlcy5cbiAqIEBwYXJhbSBjcmVhdGVFbGVtZW50IC0gQSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlIHdyYXBwaW5nIEVsZW1lbnROb2RlLiBlZy4gJGNyZWF0ZVBhcmFncmFwaE5vZGUuXG4gKiBAcGFyYW0gd3JhcHBpbmdFbGVtZW50IC0gQW4gZWxlbWVudCB0byB3cmFwIGFsbCB0aGUgbm9kZXMgaW50by5cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uICR3cmFwTm9kZXNJbXBsKHNlbGVjdGlvbiwgbm9kZXMsIG5vZGVzTGVuZ3RoLCBjcmVhdGVFbGVtZW50LCB3cmFwcGluZ0VsZW1lbnQgPSBudWxsKSB7XG4gIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZmlyc3ROb2RlID0gbm9kZXNbMF07XG4gIGNvbnN0IGVsZW1lbnRNYXBwaW5nID0gbmV3IE1hcCgpO1xuICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAvLyBUaGUgYmVsb3cgbG9naWMgaXMgdG8gZmluZCB0aGUgcmlnaHQgdGFyZ2V0IGZvciB1cyB0b1xuICAvLyBlaXRoZXIgaW5zZXJ0QWZ0ZXIvaW5zZXJ0QmVmb3JlL2FwcGVuZCB0aGUgY29ycmVzcG9uZGluZ1xuICAvLyBlbGVtZW50cyB0by4gVGhpcyBpcyBtYWRlIG1vcmUgY29tcGxpY2F0ZWQgZHVlIHRvIG5lc3RlZFxuICAvLyBzdHJ1Y3R1cmVzLlxuICBsZXQgdGFyZ2V0ID0gJGlzRWxlbWVudE5vZGUoZmlyc3ROb2RlKSA/IGZpcnN0Tm9kZSA6IGZpcnN0Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIGlmICh0YXJnZXQuaXNJbmxpbmUoKSkge1xuICAgIHRhcmdldCA9IHRhcmdldC5nZXRQYXJlbnRPclRocm93KCk7XG4gIH1cbiAgbGV0IHRhcmdldElzUHJldlNpYmxpbmcgPSBmYWxzZTtcbiAgd2hpbGUgKHRhcmdldCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdGFyZ2V0LmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGlmIChwcmV2U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgdGFyZ2V0ID0gcHJldlNpYmxpbmc7XG4gICAgICB0YXJnZXRJc1ByZXZTaWJsaW5nID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0YXJnZXQgPSB0YXJnZXQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGlmICgkaXNSb290T3JTaGFkb3dSb290KHRhcmdldCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCBlbXB0eUVsZW1lbnRzID0gbmV3IFNldCgpO1xuXG4gIC8vIEZpbmQgYW55IHRvcCBsZXZlbCBlbXB0eSBlbGVtZW50c1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpICYmIG5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICAgIGVtcHR5RWxlbWVudHMuYWRkKG5vZGUuZ2V0S2V5KCkpO1xuICAgIH1cbiAgfVxuICBjb25zdCBtb3ZlZE5vZGVzID0gbmV3IFNldCgpO1xuXG4gIC8vIE1vdmUgb3V0IGFsbCBsZWFmIG5vZGVzIGludG8gb3VyIGVsZW1lbnRzIGFycmF5LlxuICAvLyBJZiB3ZSBmaW5kIGEgdG9wIGxldmVsIGVtcHR5IGVsZW1lbnQsIGFsc28gbW92ZSBtYWtlXG4gIC8vIGFuIGVsZW1lbnQgZm9yIHRoYXQuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBsZXQgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICBpZiAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC5pc0lubGluZSgpKSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gICAgfVxuICAgIGlmIChwYXJlbnQgIT09IG51bGwgJiYgJGlzTGVhZk5vZGUobm9kZSkgJiYgIW1vdmVkTm9kZXMuaGFzKG5vZGUuZ2V0S2V5KCkpKSB7XG4gICAgICBjb25zdCBwYXJlbnRLZXkgPSBwYXJlbnQuZ2V0S2V5KCk7XG4gICAgICBpZiAoZWxlbWVudE1hcHBpbmcuZ2V0KHBhcmVudEtleSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gY3JlYXRlRWxlbWVudCgpO1xuICAgICAgICB0YXJnZXRFbGVtZW50LnNldEZvcm1hdChwYXJlbnQuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5zZXRJbmRlbnQocGFyZW50LmdldEluZGVudCgpKTtcbiAgICAgICAgZWxlbWVudHMucHVzaCh0YXJnZXRFbGVtZW50KTtcbiAgICAgICAgZWxlbWVudE1hcHBpbmcuc2V0KHBhcmVudEtleSwgdGFyZ2V0RWxlbWVudCk7XG4gICAgICAgIC8vIE1vdmUgbm9kZSBhbmQgaXRzIHNpYmxpbmdzIHRvIHRoZSBuZXdcbiAgICAgICAgLy8gZWxlbWVudC5cbiAgICAgICAgcGFyZW50LmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgdGFyZ2V0RWxlbWVudC5hcHBlbmQoY2hpbGQpO1xuICAgICAgICAgIG1vdmVkTm9kZXMuYWRkKGNoaWxkLmdldEtleSgpKTtcbiAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgICAvLyBTa2lwIG5lc3RlZCBsZWFmIG5vZGVzIGlmIHRoZSBwYXJlbnQgaGFzIGFscmVhZHkgYmVlbiBtb3ZlZFxuICAgICAgICAgICAgY2hpbGQuZ2V0Q2hpbGRyZW5LZXlzKCkuZm9yRWFjaChrZXkgPT4gbW92ZWROb2Rlcy5hZGQoa2V5KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgJHJlbW92ZVBhcmVudEVtcHR5RWxlbWVudHMocGFyZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVtcHR5RWxlbWVudHMuaGFzKG5vZGUuZ2V0S2V5KCkpKSB7XG4gICAgICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBub2RlIGluIGVtcHR5RWxlbWVudHMgdG8gYmUgYW4gRWxlbWVudE5vZGVgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCk7XG4gICAgICB0YXJnZXRFbGVtZW50LnNldEZvcm1hdChub2RlLmdldEZvcm1hdFR5cGUoKSk7XG4gICAgICB0YXJnZXRFbGVtZW50LnNldEluZGVudChub2RlLmdldEluZGVudCgpKTtcbiAgICAgIGVsZW1lbnRzLnB1c2godGFyZ2V0RWxlbWVudCk7XG4gICAgICBub2RlLnJlbW92ZSh0cnVlKTtcbiAgICB9XG4gIH1cbiAgaWYgKHdyYXBwaW5nRWxlbWVudCAhPT0gbnVsbCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIHdyYXBwaW5nRWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XG4gICAgfVxuICB9XG4gIGxldCBsYXN0RWxlbWVudCA9IG51bGw7XG5cbiAgLy8gSWYgb3VyIHRhcmdldCBpcyBSb290LWxpa2UsIGxldCdzIHNlZSBpZiB3ZSBjYW4gcmUtYWRqdXN0XG4gIC8vIHNvIHRoYXQgdGhlIHRhcmdldCBpcyB0aGUgZmlyc3QgY2hpbGQgaW5zdGVhZC5cbiAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QodGFyZ2V0KSkge1xuICAgIGlmICh0YXJnZXRJc1ByZXZTaWJsaW5nKSB7XG4gICAgICBpZiAod3JhcHBpbmdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHRhcmdldC5pbnNlcnRBZnRlcih3cmFwcGluZ0VsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGVsZW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICAgIHRhcmdldC5pbnNlcnRBZnRlcihlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmaXJzdENoaWxkID0gdGFyZ2V0LmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgICB0YXJnZXQgPSBmaXJzdENoaWxkO1xuICAgICAgfVxuICAgICAgaWYgKGZpcnN0Q2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHdyYXBwaW5nRWxlbWVudCkge1xuICAgICAgICAgIHRhcmdldC5hcHBlbmQod3JhcHBpbmdFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICB0YXJnZXQuYXBwZW5kKGVsZW1lbnQpO1xuICAgICAgICAgICAgbGFzdEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHdyYXBwaW5nRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUoZWxlbWVudCk7XG4gICAgICAgICAgICBsYXN0RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh3cmFwcGluZ0VsZW1lbnQpIHtcbiAgICAgIHRhcmdldC5pbnNlcnRBZnRlcih3cmFwcGluZ0VsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gZWxlbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIoZWxlbWVudCk7XG4gICAgICAgIGxhc3RFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgcHJldlNlbGVjdGlvbiA9ICRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgaXNQb2ludEF0dGFjaGVkKHByZXZTZWxlY3Rpb24uYW5jaG9yKSAmJiBpc1BvaW50QXR0YWNoZWQocHJldlNlbGVjdGlvbi5mb2N1cykpIHtcbiAgICAkc2V0U2VsZWN0aW9uKHByZXZTZWxlY3Rpb24uY2xvbmUoKSk7XG4gIH0gZWxzZSBpZiAobGFzdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICBsYXN0RWxlbWVudC5zZWxlY3RFbmQoKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxlY3Rpb24uZGlydHkgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZGVmYXVsdCBjaGFyYWN0ZXIgc2VsZWN0aW9uIHNob3VsZCBiZSBvdmVycmlkZGVuLiBVc2VkIHdpdGggRGVjb3JhdG9yTm9kZXNcbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIHdob3NlIGRlZmF1bHQgY2hhcmFjdGVyIHNlbGVjdGlvbiBtYXkgbmVlZCB0byBiZSBvdmVycmlkZGVuLlxuICogQHBhcmFtIGlzQmFja3dhcmQgLSBJcyB0aGUgc2VsZWN0aW9uIGJhY2t3YXJkcyAodGhlIGZvY3VzIGNvbWVzIGJlZm9yZSB0aGUgYW5jaG9yKT9cbiAqIEByZXR1cm5zIHRydWUgaWYgaXQgc2hvdWxkIGJlIG92ZXJyaWRkZW4sIGZhbHNlIGlmIG5vdC5cbiAqL1xuZnVuY3Rpb24gJHNob3VsZE92ZXJyaWRlRGVmYXVsdENoYXJhY3RlclNlbGVjdGlvbihzZWxlY3Rpb24sIGlzQmFja3dhcmQpIHtcbiAgY29uc3QgcG9zc2libGVOb2RlID0gJGdldEFkamFjZW50Tm9kZShzZWxlY3Rpb24uZm9jdXMsIGlzQmFja3dhcmQpO1xuICByZXR1cm4gJGlzRGVjb3JhdG9yTm9kZShwb3NzaWJsZU5vZGUpICYmICFwb3NzaWJsZU5vZGUuaXNJc29sYXRlZCgpIHx8ICRpc0VsZW1lbnROb2RlKHBvc3NpYmxlTm9kZSkgJiYgIXBvc3NpYmxlTm9kZS5pc0lubGluZSgpICYmICFwb3NzaWJsZU5vZGUuY2FuQmVFbXB0eSgpO1xufVxuXG4vKipcbiAqIE1vdmVzIHRoZSBzZWxlY3Rpb24gYWNjb3JkaW5nIHRvIHRoZSBhcmd1bWVudHMuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGVkIHRleHQgb3Igbm9kZXMuXG4gKiBAcGFyYW0gaXNIb2xkaW5nU2hpZnQgLSBJcyB0aGUgc2hpZnQga2V5IGJlaW5nIGhlbGQgZG93biBkdXJpbmcgdGhlIG9wZXJhdGlvbi5cbiAqIEBwYXJhbSBpc0JhY2t3YXJkIC0gSXMgdGhlIHNlbGVjdGlvbiBzZWxlY3RlZCBiYWNrd2FyZHMgKHRoZSBmb2N1cyBjb21lcyBiZWZvcmUgdGhlIGFuY2hvcik/XG4gKiBAcGFyYW0gZ3JhbnVsYXJpdHkgLSBUaGUgZGlzdGFuY2UgdG8gYWRqdXN0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gJG1vdmVDYXJldFNlbGVjdGlvbihzZWxlY3Rpb24sIGlzSG9sZGluZ1NoaWZ0LCBpc0JhY2t3YXJkLCBncmFudWxhcml0eSkge1xuICBzZWxlY3Rpb24ubW9kaWZ5KGlzSG9sZGluZ1NoaWZ0ID8gJ2V4dGVuZCcgOiAnbW92ZScsIGlzQmFja3dhcmQsIGdyYW51bGFyaXR5KTtcbn1cblxuLyoqXG4gKiBUZXN0cyBhIHBhcmVudCBlbGVtZW50IGZvciByaWdodCB0byBsZWZ0IGRpcmVjdGlvbi5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIHdob3NlIHBhcmVudCBpcyB0byBiZSB0ZXN0ZWQuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBzZWxlY3Rpb25zJyBwYXJlbnQgZWxlbWVudCBoYXMgYSBkaXJlY3Rpb24gb2YgJ3J0bCcgKHJpZ2h0IHRvIGxlZnQpLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uICRpc1BhcmVudEVsZW1lbnRSVEwoc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgcGFyZW50ID0gJGlzUm9vdE5vZGUoYW5jaG9yTm9kZSkgPyBhbmNob3JOb2RlIDogYW5jaG9yTm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIHJldHVybiBwYXJlbnQuZ2V0RGlyZWN0aW9uKCkgPT09ICdydGwnO1xufVxuXG4vKipcbiAqIE1vdmVzIHNlbGVjdGlvbiBieSBjaGFyYWN0ZXIgYWNjb3JkaW5nIHRvIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIG9mIHRoZSBjaGFyYWN0ZXJzIHRvIG1vdmUuXG4gKiBAcGFyYW0gaXNIb2xkaW5nU2hpZnQgLSBJcyB0aGUgc2hpZnQga2V5IGJlaW5nIGhlbGQgZG93biBkdXJpbmcgdGhlIG9wZXJhdGlvbi5cbiAqIEBwYXJhbSBpc0JhY2t3YXJkIC0gSXMgdGhlIHNlbGVjdGlvbiBiYWNrd2FyZCAodGhlIGZvY3VzIGNvbWVzIGJlZm9yZSB0aGUgYW5jaG9yKT9cbiAqL1xuZnVuY3Rpb24gJG1vdmVDaGFyYWN0ZXIoc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgaXNCYWNrd2FyZCkge1xuICBjb25zdCBpc1JUTCA9ICRpc1BhcmVudEVsZW1lbnRSVEwoc2VsZWN0aW9uKTtcbiAgJG1vdmVDYXJldFNlbGVjdGlvbihzZWxlY3Rpb24sIGlzSG9sZGluZ1NoaWZ0LCBpc0JhY2t3YXJkID8gIWlzUlRMIDogaXNSVEwsICdjaGFyYWN0ZXInKTtcbn1cblxuLyoqXG4gKiBFeHBhbmRzIHRoZSBjdXJyZW50IFNlbGVjdGlvbiB0byBjb3ZlciBhbGwgb2YgdGhlIGNvbnRlbnQgaW4gdGhlIGVkaXRvci5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uICRzZWxlY3RBbGwoc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgdG9wUGFyZW50ID0gYW5jaG9yTm9kZS5nZXRUb3BMZXZlbEVsZW1lbnRPclRocm93KCk7XG4gIGNvbnN0IHJvb3QgPSB0b3BQYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICBsZXQgZmlyc3ROb2RlID0gcm9vdC5nZXRGaXJzdERlc2NlbmRhbnQoKTtcbiAgbGV0IGxhc3ROb2RlID0gcm9vdC5nZXRMYXN0RGVzY2VuZGFudCgpO1xuICBsZXQgZmlyc3RUeXBlID0gJ2VsZW1lbnQnO1xuICBsZXQgbGFzdFR5cGUgPSAnZWxlbWVudCc7XG4gIGxldCBsYXN0T2Zmc2V0ID0gMDtcbiAgaWYgKCRpc1RleHROb2RlKGZpcnN0Tm9kZSkpIHtcbiAgICBmaXJzdFR5cGUgPSAndGV4dCc7XG4gIH0gZWxzZSBpZiAoISRpc0VsZW1lbnROb2RlKGZpcnN0Tm9kZSkgJiYgZmlyc3ROb2RlICE9PSBudWxsKSB7XG4gICAgZmlyc3ROb2RlID0gZmlyc3ROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgfVxuICBpZiAoJGlzVGV4dE5vZGUobGFzdE5vZGUpKSB7XG4gICAgbGFzdFR5cGUgPSAndGV4dCc7XG4gICAgbGFzdE9mZnNldCA9IGxhc3ROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICB9IGVsc2UgaWYgKCEkaXNFbGVtZW50Tm9kZShsYXN0Tm9kZSkgJiYgbGFzdE5vZGUgIT09IG51bGwpIHtcbiAgICBsYXN0Tm9kZSA9IGxhc3ROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgfVxuICBpZiAoZmlyc3ROb2RlICYmIGxhc3ROb2RlKSB7XG4gICAgYW5jaG9yLnNldChmaXJzdE5vZGUuZ2V0S2V5KCksIDAsIGZpcnN0VHlwZSk7XG4gICAgZm9jdXMuc2V0KGxhc3ROb2RlLmdldEtleSgpLCBsYXN0T2Zmc2V0LCBsYXN0VHlwZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgQ1NTIHByb3BlcnR5IGZvciBOb2RlcywgaWYgc2V0LiBJZiBub3Qgc2V0LCBpdCByZXR1cm5zIHRoZSBkZWZhdWx0VmFsdWUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHdob3NlIHN0eWxlIHZhbHVlIHRvIGdldC5cbiAqIEBwYXJhbSBzdHlsZVByb3BlcnR5IC0gVGhlIENTUyBzdHlsZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHByb3BlcnR5LlxuICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBmb3Igbm9kZS5cbiAqL1xuZnVuY3Rpb24gJGdldE5vZGVTdHlsZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgc3R5bGVQcm9wZXJ0eSwgZGVmYXVsdFZhbHVlKSB7XG4gIGNvbnN0IGNzcyA9IG5vZGUuZ2V0U3R5bGUoKTtcbiAgY29uc3Qgc3R5bGVPYmplY3QgPSBnZXRTdHlsZU9iamVjdEZyb21DU1MoY3NzKTtcbiAgaWYgKHN0eWxlT2JqZWN0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHN0eWxlT2JqZWN0W3N0eWxlUHJvcGVydHldIHx8IGRlZmF1bHRWYWx1ZTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFZhbHVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBDU1MgcHJvcGVydHkgZm9yIFRleHROb2RlcyBpbiB0aGUgU2VsZWN0aW9uLCBpZiBzZXQuIElmIG5vdCBzZXQsIGl0IHJldHVybnMgdGhlIGRlZmF1bHRWYWx1ZS5cbiAqIElmIGFsbCBUZXh0Tm9kZXMgZG8gbm90IGhhdmUgdGhlIHNhbWUgdmFsdWUsIGl0IHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gb2YgVGV4dE5vZGVzIHdob3NlIHZhbHVlIHRvIGZpbmQuXG4gKiBAcGFyYW0gc3R5bGVQcm9wZXJ0eSAtIFRoZSBDU1Mgc3R5bGUgcHJvcGVydHkuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIC0gVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBwcm9wZXJ0eSwgZGVmYXVsdHMgdG8gYW4gZW1wdHkgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBmb3IgdGhlIHNlbGVjdGVkIFRleHROb2Rlcy5cbiAqL1xuZnVuY3Rpb24gJGdldFNlbGVjdGlvblN0eWxlVmFsdWVGb3JQcm9wZXJ0eShzZWxlY3Rpb24sIHN0eWxlUHJvcGVydHksIGRlZmF1bHRWYWx1ZSA9ICcnKSB7XG4gIGxldCBzdHlsZVZhbHVlID0gbnVsbDtcbiAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGNvbnN0IGlzQmFja3dhcmQgPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpO1xuICBjb25zdCBlbmRPZmZzZXQgPSBpc0JhY2t3YXJkID8gZm9jdXMub2Zmc2V0IDogYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgZW5kTm9kZSA9IGlzQmFja3dhcmQgPyBmb2N1cy5nZXROb2RlKCkgOiBhbmNob3IuZ2V0Tm9kZSgpO1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBzZWxlY3Rpb24uc3R5bGUgIT09ICcnKSB7XG4gICAgY29uc3QgY3NzID0gc2VsZWN0aW9uLnN0eWxlO1xuICAgIGNvbnN0IHN0eWxlT2JqZWN0ID0gZ2V0U3R5bGVPYmplY3RGcm9tQ1NTKGNzcyk7XG4gICAgaWYgKHN0eWxlT2JqZWN0ICE9PSBudWxsICYmIHN0eWxlUHJvcGVydHkgaW4gc3R5bGVPYmplY3QpIHtcbiAgICAgIHJldHVybiBzdHlsZU9iamVjdFtzdHlsZVByb3BlcnR5XTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblxuICAgIC8vIGlmIG5vIGFjdHVhbCBjaGFyYWN0ZXJzIGluIHRoZSBlbmQgbm9kZSBhcmUgc2VsZWN0ZWQsIHdlIGRvbid0XG4gICAgLy8gaW5jbHVkZSBpdCBpbiB0aGUgc2VsZWN0aW9uIGZvciBwdXJwb3NlcyBvZiBkZXRlcm1pbmluZyBzdHlsZVxuICAgIC8vIHZhbHVlXG4gICAgaWYgKGkgIT09IDAgJiYgZW5kT2Zmc2V0ID09PSAwICYmIG5vZGUuaXMoZW5kTm9kZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IG5vZGVTdHlsZVZhbHVlID0gJGdldE5vZGVTdHlsZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgc3R5bGVQcm9wZXJ0eSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgIGlmIChzdHlsZVZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHN0eWxlVmFsdWUgPSBub2RlU3R5bGVWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGVWYWx1ZSAhPT0gbm9kZVN0eWxlVmFsdWUpIHtcbiAgICAgICAgLy8gbXVsdGlwbGUgdGV4dCBub2RlcyBhcmUgaW4gdGhlIHNlbGVjdGlvbiBhbmQgdGhleSBkb24ndCBhbGxcbiAgICAgICAgLy8gaGF2ZSB0aGUgc2FtZSBzdHlsZS5cbiAgICAgICAgc3R5bGVWYWx1ZSA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlVmFsdWUgPT09IG51bGwgPyBkZWZhdWx0VmFsdWUgOiBzdHlsZVZhbHVlO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZm9yIGludGVybmFsIHVzZSBvZiB0aGUgbGlicmFyeS5cbiAqIFBsZWFzZSBkbyBub3QgdXNlIGl0IGFzIGl0IG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAqL1xuZnVuY3Rpb24gSU5URVJOQUxfJGlzQmxvY2sobm9kZSkge1xuICBpZiAoJGlzRGVjb3JhdG9yTm9kZShub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpIHx8ICRpc1Jvb3RPclNoYWRvd1Jvb3Qobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZmlyc3RDaGlsZCA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICBjb25zdCBpc0xlYWZFbGVtZW50ID0gZmlyc3RDaGlsZCA9PT0gbnVsbCB8fCAkaXNMaW5lQnJlYWtOb2RlKGZpcnN0Q2hpbGQpIHx8ICRpc1RleHROb2RlKGZpcnN0Q2hpbGQpIHx8IGZpcnN0Q2hpbGQuaXNJbmxpbmUoKTtcbiAgcmV0dXJuICFub2RlLmlzSW5saW5lKCkgJiYgbm9kZS5jYW5CZUVtcHR5KCkgIT09IGZhbHNlICYmIGlzTGVhZkVsZW1lbnQ7XG59XG5mdW5jdGlvbiAkZ2V0QW5jZXN0b3Iobm9kZSwgcHJlZGljYXRlKSB7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC5nZXRQYXJlbnQoKSAhPT0gbnVsbCAmJiAhcHJlZGljYXRlKHBhcmVudCkpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICB9XG4gIHJldHVybiBwcmVkaWNhdGUocGFyZW50KSA/IHBhcmVudCA6IG51bGw7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8ge0BsaW5rICR0cmltVGV4dENvbnRlbnRGcm9tQW5jaG9yfSBieSBAbGV4aWNhbC9lc2xpbnQtcGx1Z2luIHJ1bGVzLW9mLWxleGljYWwgKi9cbmNvbnN0IHRyaW1UZXh0Q29udGVudEZyb21BbmNob3IgPSAkdHJpbVRleHRDb250ZW50RnJvbUFuY2hvcjtcblxuZXhwb3J0IHsgJGFkZE5vZGVTdHlsZSwgJGdldFNlbGVjdGlvblN0eWxlVmFsdWVGb3JQcm9wZXJ0eSwgJGlzQXROb2RlRW5kLCAkaXNQYXJlbnRFbGVtZW50UlRMLCAkbW92ZUNhcmV0U2VsZWN0aW9uLCAkbW92ZUNoYXJhY3RlciwgJHBhdGNoU3R5bGVUZXh0LCAkc2VsZWN0QWxsLCAkc2V0QmxvY2tzVHlwZSwgJHNob3VsZE92ZXJyaWRlRGVmYXVsdENoYXJhY3RlclNlbGVjdGlvbiwgJHNsaWNlU2VsZWN0ZWRUZXh0Tm9kZUNvbnRlbnQsICR0cmltVGV4dENvbnRlbnRGcm9tQW5jaG9yLCAkd3JhcE5vZGVzLCBjcmVhdGVET01SYW5nZSwgY3JlYXRlUmVjdHNGcm9tRE9NUmFuZ2UsIGdldENTU0Zyb21TdHlsZU9iamVjdCwgZ2V0U3R5bGVPYmplY3RGcm9tQ1NTLCB0cmltVGV4dENvbnRlbnRGcm9tQW5jaG9yIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@lexical+selection@0.21.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs\n");

/***/ })

};
;